Overview of the Project
I have developed a CRUD API using Spring Boot and a UI using React JS + Vite. I have used Git and GitHub for branching and pull requests. I have used Docker, Docker Hub, Kubernetes, and AWS for deployment.

Prerequisites for Running the Application
Tech Stack
Frontend Stack
HTML
Tailwind CSS
React JS
JavaScript
Backend Stack
Distributed Systems
Git
GitHub
GitHub Actions (CI/CD)
API
Spring Boot, MVC, Spring
Java
Postman (API Testing)
Cloud
Docker, Docker Hub
Kubernetes (EKS)
AWS (EKS, IAM, EC2, Elastic IP, VPC, CloudFormation)
Instructions for Development of UI and Setting Up and Running the Backend API
Frontend UI (React JS + Vite)
Create functional components to add, update, delete, and list views.
Use React Router Dom for page routing, and Tailwind CSS for basic styling.
Use React Material UI and Axios for backend API fetch.
Store Docker images in Docker Hub Repo using a CI/CD basic pipeline.
Use React JS event handling and hooks (useState, useEffect).
Use Vite for fast, productive, and effective work.
Best practices: Use Prettier for code formatting to save time and energy, and be more productive.
Use ESLint configuration for automatic incorrect pattern detection, improving code quality, making code more consistent, and avoiding bugs.
Build the project; the dist folder will be there.
Backend Development
Use Eclipse for API development.
Use the MVC model for this project.
Full path: React JS UI --> (Request Class) --> Controller --> Handler --> Service Interface --> Service --> Dao Interface (MySQL and PostgreSQL using CRUD or JPA Repo for CRUD methods) --> Dao (Optional) --> (Response Class).
Controller: API Endpoints and Request Class parameter.
Service: Write the main logic for any API (CRUD). Examples: Login, Register, E-KYC, Product Invoice, payment logic, payment integration.
Dao: Interact with databases like MySQL, PostgreSQL, MongoDB. Write custom queries.
Request and Response Class: Handle input and output data.
Best Practices: Use packages for constants, utils, common request, and common response.
Build the project; a JAR file will be created for production-level deployment.
API Endpoints
This project includes the development of 5 APIs using Spring Boot:

GET API: Retrieve model data.
PUT API: Update model data.
DELETE API: Delete model data.
GET ALL API: Retrieve all data.
POST API: Add data.
All APIs can be tested using Postman.
CORS Policy
Configure the file for CORS policy to allow all frontend IP addresses or localhost addresses.
This is necessary to allow backend API fetch requests from the frontend.
API Testing
Use Postman to test all APIs.
POST and PUT can use JSON body, and all other APIs can use an ID in the URL.
Database Connection
Use the application.yaml file to configure the database connection.
This file can be used for both development and production-level configuration.
Use application.dev.yaml and application.prod.yaml for profiles used in different environments like Dev, QA, and Production.
Use ORM dependencies like JPA to connect the database to the object table.
Validation
Use validation dependencies for model attribute validation.
Distributed Systems
Information on How to Add the Evaluator as a Collaborator on GitHub
Git: Use commands like git add -A, git commit, git clone, git remote -v, git pull, git push origin, git add origin, git branch, git status, git checkout -b branch.

GitHub: Create repositories, sub-branches, pull requests, review branches, merge branches, etc.

GitHub Actions (CI/CD): Create automation workflows for any update on a branch.

Example: Push on a branch, then the pipeline automatically runs (estimated time 2-3 minutes approx).
Build Dockerfile images for frontend and backend.
Login to Docker Hub (add secret ID and password).
Push Docker images to Docker Hub.
Automate deployment (manual deployment can be added as an option).
Always work with the team and the team lead on GitHub. If the client demands new features, distribute work on branches to the development branch.

Push your code and check for any updates on the development branch. Your teammates might push their code to the main development branch; pull the latest code and merge it before creating a pull request.

Many pull requests can also be viewed by the team lead. The team lead can issue suggestions on GitHub, review pull requests, and merge the PR code.

Use tags for release updates like v1, v2, etc.

Follow Agile methodology with daily scrums for 5-10 minutes, bi-weekly sprint reviews for the team lead, and monthly meetings with all team members, scrum master, and product owner for new month planning.

Use collaboration tools like Email, Microsoft Teams, Google Meet, and Jira for feature timelines.

Log hours daily on Jira (sometimes missed).

Collaborate with the team for client discussions, pizza parties, and more.

Branch Workflow (Original)
main: Production branch
staging: Pre-production branch
qa: Testing branch
developer: Development branch (many feature branches for different developers)
My Workflow
main
development
Kubernetes and Docker with AWS
Docker
Create Dockerfiles for frontend and backend images.
Store Docker images in Docker Hub or Amazon Container Registry.
Use Docker commands: docker ps, docker images, docker login, docker pull, docker push.
Automate Docker image builds and pushes to Docker Hub using a CI/CD pipeline with GitHub Actions.
Kubernetes with AWS
Kubernetes can run on the cloud and locally.
Cloud: EKS, AKS
Local: Minikube
First Step
Create a Kubernetes cluster using Minikube, Kind, or Eksctl.
A Kubernetes cluster can hold one master node and worker nodes.
Second Step
Login to AWS and create an EC2 instance. Connect via SSH using a private key or browser.
Create IAM with admin access.
Login to AWS CLI using IAM user on the EC2 instance.
Third Step
Install kubectl and eksctl on the EC2 instance.

Install kubectl:
curl -o kubectl https://amazon-eks.s3.us-west-2.amazonaws.com/1.19.6/2021-01-05/bin/linux/amd64/kubectl
chmod +x ./kubectl
Install eksctl:
eksctl create cluster --name three-tier-cluster --region us-west-2 --node-type t2.medium --nodes-min 2 --nodes-max 2
Set up the first cluster in Kubernetes using eksctl code:
eksctl create cluster --name three-tier-cluster --region us-west-2 --node-type t2.medium --nodes-min 2 --nodes-max 2
Connect the cluster and kubectl using this command in EC2:
aws eks update-kubeconfig --region us-west-2 --name three-tier-cluster
Kubectl: Communicate or check the status of Kubernetes clusters like pods, deployment, and services.

Commands: kubectl get pods, kubectl get deployment, kubectl get svc, kubectl version, kubectl logs, kubectl describe, kubectl apply -f and many more.
Eksctl: Create clusters for Kubernetes. The backend side cloud formation can create all things.

Fourth Step
Create YAML or manifest files for deployment, service, secrets, ingress, and load balancer.
Deployment.yaml: Deploy images in pods.
Service.yaml: Communicate inside pods using service (e.g., database can communicate with Spring Boot app).
Secrets.yaml: Hold all secrets like database username and password.
Ingress: Simple routing like React Router Dom. You have three pods (frontend, backend, and database) in three different IPv4 addresses. You can access any one using ingress.
Load Balancer: Users cannot directly access the cluster. Use a load balancer to load balance and interact with the Kubernetes cluster.
Fifth Step
Writing YAML files can be hard. Use Helm charts for predefined structures for deployment, service, secrets, horizontal scaling, and more.
If using Windows, use Chocolatey for installing Helm charts.
Helm can have values.yaml, Chart.yaml, and a template folder.
Change Helm charts and apply them to easily create manifest files.
Sixth Step
Use kubectl to deploy all pods.